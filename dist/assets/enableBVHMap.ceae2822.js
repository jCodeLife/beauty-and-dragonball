var he=Object.defineProperty,ye=Object.defineProperties;var me=Object.getOwnPropertyDescriptors;var Ht=Object.getOwnPropertySymbols;var xe=Object.prototype.hasOwnProperty,we=Object.prototype.propertyIsEnumerable;var kt=(n,t,e)=>t in n?he(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,ft=(n,t)=>{for(var e in t||(t={}))xe.call(t,e)&&kt(n,e,t[e]);if(Ht)for(var e of Ht(t))we.call(t,e)&&kt(n,e,t[e]);return n},Ot=(n,t)=>ye(n,me(t));import{i as F,V as at,G as ae,ai as k,aj as Et,ak as Ae,al as Y,y as bt,am as Tt,an as Gt,_ as ge,k as be,ao as Te,a1 as Pe,a0 as Be,x as le,I as an,N as ln,ap as fn,aq as un,J as pn,ar as dn,U as hn,as as yn,at as mn,R as xn,au as wn,av as An,aw as gn,ax as bn,ay as Tn,az as Me,a9 as Se,s as Mt,aA as Ie,aB as ve}from"./index.255e6eef.js";import{p as Fe,a as ze}from"./useBVHMap.4a143400.js";const fe=0,Ee=1,Ce=2,jt=2,St=1.25,Xt=1,At=6*4+4+4,Ct=65535,Ue=Math.pow(2,-24);class ut{constructor(){}}function _(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function Wt(n){let t=-1,e=-1/0;for(let i=0;i<3;i++){const s=n[i+3]-n[i];s>e&&(e=s,t=i)}return t}function Yt(n,t){t.set(n)}function Zt(n,t,e){let i,s;for(let o=0;o<3;o++){const r=o+3;i=n[o],s=t[o],e[o]=i<s?i:s,i=n[r],s=t[r],e[r]=i>s?i:s}}function pt(n,t,e){for(let i=0;i<3;i++){const s=t[n+2*i],o=t[n+2*i+1],r=s-o,l=s+o;r<e[i]&&(e[i]=r),l>e[i+3]&&(e[i+3]=l)}}function et(n){const t=n[3]-n[0],e=n[4]-n[1],i=n[5]-n[2];return 2*(t*e+e*i+i*t)}function Ve(n,t){if(!n.index){const e=n.attributes.position.count,i=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let s;e>65535?s=new Uint32Array(new i(4*e)):s=new Uint16Array(new i(2*e)),n.setIndex(new Tt(s,1));for(let o=0;o<e;o++)s[o]=o}}function Re(n){if(!n.groups||!n.groups.length)return[{offset:0,count:n.index.count/3}];const t=[],e=new Set;for(const s of n.groups)e.add(s.start),e.add(s.start+s.count);const i=Array.from(e.values()).sort((s,o)=>s-o);for(let s=0;s<i.length-1;s++){const o=i[s],r=i[s+1];t.push({offset:o/3,count:(r-o)/3})}return t}function It(n,t,e,i,s=null){let o=1/0,r=1/0,l=1/0,c=-1/0,f=-1/0,a=-1/0,u=1/0,p=1/0,d=1/0,g=-1/0,w=-1/0,A=-1/0;const y=s!==null;for(let m=t*6,h=(t+e)*6;m<h;m+=6){const x=n[m+0],b=n[m+1],T=x-b,M=x+b;T<o&&(o=T),M>c&&(c=M),y&&x<u&&(u=x),y&&x>g&&(g=x);const B=n[m+2],P=n[m+3],S=B-P,I=B+P;S<r&&(r=S),I>f&&(f=I),y&&B<p&&(p=B),y&&B>w&&(w=B);const v=n[m+4],z=n[m+5],U=v-z,E=v+z;U<l&&(l=U),E>a&&(a=E),y&&v<d&&(d=v),y&&v>A&&(A=v)}i[0]=o,i[1]=r,i[2]=l,i[3]=c,i[4]=f,i[5]=a,y&&(s[0]=u,s[1]=p,s[2]=d,s[3]=g,s[4]=w,s[5]=A)}function _e(n,t,e,i){let s=1/0,o=1/0,r=1/0,l=-1/0,c=-1/0,f=-1/0;for(let a=t*6,u=(t+e)*6;a<u;a+=6){const p=n[a+0];p<s&&(s=p),p>l&&(l=p);const d=n[a+2];d<o&&(o=d),d>c&&(c=d);const g=n[a+4];g<r&&(r=g),g>f&&(f=g)}i[0]=s,i[1]=o,i[2]=r,i[3]=l,i[4]=c,i[5]=f}function Le(n,t,e,i,s){let o=e,r=e+i-1;const l=s.pos,c=s.axis*2;for(;;){for(;o<=r&&t[o*6+c]<l;)o++;for(;o<=r&&t[r*6+c]>=l;)r--;if(o<r){for(let f=0;f<3;f++){let a=n[o*3+f];n[o*3+f]=n[r*3+f],n[r*3+f]=a;let u=t[o*6+f*2+0];t[o*6+f*2+0]=t[r*6+f*2+0],t[r*6+f*2+0]=u;let p=t[o*6+f*2+1];t[o*6+f*2+1]=t[r*6+f*2+1],t[r*6+f*2+1]=p}o++,r--}else return o}}const H=32,De=(n,t)=>n.candidate-t.candidate,G=new Array(H).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),dt=new Float32Array(6);function Ne(n,t,e,i,s,o){let r=-1,l=0;if(o===fe)r=Wt(t),r!==-1&&(l=(t[r]+t[r+3])/2);else if(o===Ee)r=Wt(n),r!==-1&&(l=qe(e,i,s,r));else if(o===Ce){const c=et(n);let f=St*s;const a=i*6,u=(i+s)*6;for(let p=0;p<3;p++){const d=t[p],A=(t[p+3]-d)/H;if(s<H/4){const y=[...G];y.length=s;let m=0;for(let x=a;x<u;x+=6,m++){const b=y[m];b.candidate=e[x+2*p],b.count=0;const{bounds:T,leftCacheBounds:M,rightCacheBounds:B}=b;for(let P=0;P<3;P++)B[P]=1/0,B[P+3]=-1/0,M[P]=1/0,M[P+3]=-1/0,T[P]=1/0,T[P+3]=-1/0;pt(x,e,T)}y.sort(De);let h=s;for(let x=0;x<h;x++){const b=y[x];for(;x+1<h&&y[x+1].candidate===b.candidate;)y.splice(x+1,1),h--}for(let x=a;x<u;x+=6){const b=e[x+2*p];for(let T=0;T<h;T++){const M=y[T];b>=M.candidate?pt(x,e,M.rightCacheBounds):(pt(x,e,M.leftCacheBounds),M.count++)}}for(let x=0;x<h;x++){const b=y[x],T=b.count,M=s-b.count,B=b.leftCacheBounds,P=b.rightCacheBounds;let S=0;T!==0&&(S=et(B)/c);let I=0;M!==0&&(I=et(P)/c);const v=Xt+St*(S*T+I*M);v<f&&(r=p,f=v,l=b.candidate)}}else{for(let h=0;h<H;h++){const x=G[h];x.count=0,x.candidate=d+A+h*A;const b=x.bounds;for(let T=0;T<3;T++)b[T]=1/0,b[T+3]=-1/0}for(let h=a;h<u;h+=6){let T=~~((e[h+2*p]-d)/A);T>=H&&(T=H-1);const M=G[T];M.count++,pt(h,e,M.bounds)}const y=G[H-1];Yt(y.bounds,y.rightCacheBounds);for(let h=H-2;h>=0;h--){const x=G[h],b=G[h+1];Zt(x.bounds,b.rightCacheBounds,x.rightCacheBounds)}let m=0;for(let h=0;h<H-1;h++){const x=G[h],b=x.count,T=x.bounds,B=G[h+1].rightCacheBounds;b!==0&&(m===0?Yt(T,dt):Zt(T,dt,dt)),m+=b;let P=0,S=0;m!==0&&(P=et(dt)/c);const I=s-m;I!==0&&(S=et(B)/c);const v=Xt+St*(P*m+S*I);v<f&&(r=p,f=v,l=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:r,pos:l}}function qe(n,t,e,i){let s=0;for(let o=t,r=t+e;o<r;o++)s+=n[o*6+i*2];return s/e}function He(n,t){const e=n.attributes.position,i=e.array,s=n.index.array,o=s.length/3,r=new Float32Array(o*6),l=e.offset||0;let c=3;e.isInterleavedBufferAttribute&&(c=e.data.stride);for(let f=0;f<o;f++){const a=f*3,u=f*6,p=s[a+0]*c+l,d=s[a+1]*c+l,g=s[a+2]*c+l;for(let w=0;w<3;w++){const A=i[p+w],y=i[d+w],m=i[g+w];let h=A;y<h&&(h=y),m<h&&(h=m);let x=A;y>x&&(x=y),m>x&&(x=m);const b=(x-h)/2,T=w*2;r[u+T+0]=h+b,r[u+T+1]=b+(Math.abs(h)+b)*Ue,h<t[w]&&(t[w]=h),x>t[w+3]&&(t[w+3]=x)}}return r}function ke(n,t){function e(y){p&&p(y/d)}function i(y,m,h,x=null,b=0){if(!g&&b>=c&&(g=!0,f&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(n))),h<=a||b>=c)return e(m),y.offset=m,y.count=h,y;const T=Ne(y.boundingData,x,r,m,h,u);if(T.axis===-1)return e(m),y.offset=m,y.count=h,y;const M=Le(l,r,m,h,T);if(M===m||M===m+h)e(m),y.offset=m,y.count=h;else{y.splitAxis=T.axis;const B=new ut,P=m,S=M-m;y.left=B,B.boundingData=new Float32Array(6),It(r,P,S,B.boundingData,o),i(B,P,S,o,b+1);const I=new ut,v=M,z=h-S;y.right=I,I.boundingData=new Float32Array(6),It(r,v,z,I.boundingData,o),i(I,v,z,o,b+1)}return y}Ve(n,t);const s=new Float32Array(6),o=new Float32Array(6),r=He(n,s),l=n.index.array,c=t.maxDepth,f=t.verbose,a=t.maxLeafTris,u=t.strategy,p=t.onProgress,d=n.index.count/3;let g=!1;const w=[],A=Re(n);if(A.length===1){const y=A[0],m=new ut;m.boundingData=s,_e(r,y.offset,y.count,o),i(m,y.offset,y.count,o),w.push(m)}else for(let y of A){const m=new ut;m.boundingData=new Float32Array(6),It(r,y.offset,y.count,m.boundingData,o),i(m,y.offset,y.count,o),w.push(m)}return w}function Oe(n,t){const e=ke(n,t);let i,s,o;const r=[],l=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let a=0;a<e.length;a++){const u=e[a];let p=c(u);const d=new l(At*p);i=new Float32Array(d),s=new Uint32Array(d),o=new Uint16Array(d),f(0,u),r.push(d)}return r;function c(a){return a.count?1:1+c(a.left)+c(a.right)}function f(a,u){const p=a/4,d=a/2,g=!!u.count,w=u.boundingData;for(let A=0;A<6;A++)i[p+A]=w[A];if(g){const A=u.offset,y=u.count;return s[p+6]=A,o[d+14]=y,o[d+15]=Ct,a+At}else{const A=u.left,y=u.right,m=u.splitAxis;let h;if(h=f(a+At,A),h/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return s[p+6]=h/4,h=f(h,y),s[p+7]=m,h}}}class N{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let i=1/0,s=-1/0;for(let o=0,r=t.length;o<r;o++){const c=t[o][e];i=c<i?c:i,s=c>s?c:s}this.min=i,this.max=s}setFromPoints(t,e){let i=1/0,s=-1/0;for(let o=0,r=e.length;o<r;o++){const l=e[o],c=t.dot(l);i=c<i?c:i,s=c>s?c:s}this.min=i,this.max=s}isSeparated(t){return this.min>t.max||t.min>this.max}}N.prototype.setFromBox=function(){const n=new F;return function(e,i){const s=i.min,o=i.max;let r=1/0,l=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let a=0;a<=1;a++){n.x=s.x*c+o.x*(1-c),n.y=s.y*f+o.y*(1-f),n.z=s.z*a+o.z*(1-a);const u=e.dot(n);r=Math.min(u,r),l=Math.max(u,l)}this.min=r,this.max=l}}();(function(){const n=new N;return function(e,i){const s=e.points,o=e.satAxes,r=e.satBounds,l=i.points,c=i.satAxes,f=i.satBounds;for(let a=0;a<3;a++){const u=r[a],p=o[a];if(n.setFromPoints(p,l),u.isSeparated(n))return!1}for(let a=0;a<3;a++){const u=f[a],p=c[a];if(n.setFromPoints(p,s),u.isSeparated(n))return!1}}})();const Ge=function(){const n=new F,t=new F,e=new F;return function(s,o,r){const l=s.start,c=n,f=o.start,a=t;e.subVectors(l,f),n.subVectors(s.end,o.start),t.subVectors(o.end,o.start);const u=e.dot(a),p=a.dot(c),d=a.dot(a),g=e.dot(c),A=c.dot(c)*d-p*p;let y,m;A!==0?y=(u*p-g*d)/A:y=0,m=(u+y*p)/d,r.x=y,r.y=m}}(),_t=function(){const n=new at,t=new F,e=new F;return function(s,o,r,l){Ge(s,o,n);let c=n.x,f=n.y;if(c>=0&&c<=1&&f>=0&&f<=1){s.at(c,r),o.at(f,l);return}else if(c>=0&&c<=1){f<0?o.at(0,l):o.at(1,l),s.closestPointToPoint(l,!0,r);return}else if(f>=0&&f<=1){c<0?s.at(0,r):s.at(1,r),o.closestPointToPoint(r,!0,l);return}else{let a;c<0?a=s.start:a=s.end;let u;f<0?u=o.start:u=o.end;const p=t,d=e;if(s.closestPointToPoint(u,!0,t),o.closestPointToPoint(a,!0,e),p.distanceToSquared(u)<=d.distanceToSquared(a)){r.copy(p),l.copy(u);return}else{r.copy(a),l.copy(d);return}}}}(),je=function(){const n=new F,t=new F,e=new ae,i=new k;return function(o,r){const{radius:l,center:c}=o,{a:f,b:a,c:u}=r;if(i.start=f,i.end=a,i.closestPointToPoint(c,!0,n).distanceTo(c)<=l||(i.start=f,i.end=u,i.closestPointToPoint(c,!0,n).distanceTo(c)<=l)||(i.start=a,i.end=u,i.closestPointToPoint(c,!0,n).distanceTo(c)<=l))return!0;const w=r.getPlane(e);if(Math.abs(w.distanceToPoint(c))<=l){const y=w.projectPoint(c,t);if(r.containsPoint(y))return!0}return!1}}();class O extends Et{constructor(...t){super(...t),this.isSeparatingAxisTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new F),this.satBounds=new Array(4).fill().map(()=>new N),this.points=[this.a,this.b,this.c],this.sphere=new Ae,this.plane=new ae,this.needsUpdate=!1}intersectsSphere(t){return je(t,this)}update(){const t=this.a,e=this.b,i=this.c,s=this.points,o=this.satAxes,r=this.satBounds,l=o[0],c=r[0];this.getNormal(l),c.setFromPoints(l,s);const f=o[1],a=r[1];f.subVectors(t,e),a.setFromPoints(f,s);const u=o[2],p=r[2];u.subVectors(e,i),p.setFromPoints(u,s);const d=o[3],g=r[3];d.subVectors(i,t),g.setFromPoints(d,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(l,t),this.needsUpdate=!1}}O.prototype.closestPointToSegment=function(){const n=new F,t=new F,e=new k;return function(s,o=null,r=null){const{start:l,end:c}=s,f=this.points;let a,u=1/0;for(let p=0;p<3;p++){const d=(p+1)%3;e.start.copy(f[p]),e.end.copy(f[d]),_t(e,s,n,t),a=n.distanceToSquared(t),a<u&&(u=a,o&&o.copy(n),r&&r.copy(t))}return this.closestPointToPoint(l,n),a=l.distanceToSquared(n),a<u&&(u=a,o&&o.copy(n),r&&r.copy(l)),this.closestPointToPoint(c,n),a=c.distanceToSquared(n),a<u&&(u=a,o&&o.copy(n),r&&r.copy(c)),Math.sqrt(u)}}();O.prototype.intersectsTriangle=function(){const n=new O,t=new Array(3),e=new Array(3),i=new N,s=new N,o=new F,r=new F,l=new F,c=new F,f=new k,a=new k,u=new k;return function(d,g=null){this.needsUpdate&&this.update(),d.isSeparatingAxisTriangle?d.needsUpdate&&d.update():(n.copy(d),n.update(),d=n);const w=this.satBounds,A=this.satAxes;e[0]=d.a,e[1]=d.b,e[2]=d.c;for(let h=0;h<4;h++){const x=w[h],b=A[h];if(i.setFromPoints(b,e),x.isSeparated(i))return!1}const y=d.satBounds,m=d.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let h=0;h<4;h++){const x=y[h],b=m[h];if(i.setFromPoints(b,t),x.isSeparated(i))return!1}for(let h=0;h<4;h++){const x=A[h];for(let b=0;b<4;b++){const T=m[b];if(o.crossVectors(x,T),i.setFromPoints(o,t),s.setFromPoints(o,e),i.isSeparated(s))return!1}}if(g){const h=this.plane,x=d.plane;if(Math.abs(h.normal.dot(x.normal))>1-1e-10)console.warn("SeparatingAxisTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),g.start.set(0,0,0),g.end.set(0,0,0);else{const b=this.points;let T=!1;for(let P=0;P<3;P++){const S=b[P],I=b[(P+1)%3];if(f.start.copy(S),f.end.copy(I),x.intersectLine(f,T?a.start:a.end)){if(T)break;T=!0}}const M=d.points;let B=!1;for(let P=0;P<3;P++){const S=M[P],I=M[(P+1)%3];if(f.start.copy(S),f.end.copy(I),h.intersectLine(f,B?u.start:u.end)){if(B)break;B=!0}}if(a.delta(r),u.delta(l),r.dot(l)<0){let P=u.start;u.start=u.end,u.end=P}c.subVectors(a.start,u.start),c.dot(r)>0?g.start.copy(a.start):g.start.copy(u.start),c.subVectors(a.end,u.end),c.dot(r)<0?g.end.copy(a.end):g.end.copy(u.end)}}return!0}}();O.prototype.distanceToPoint=function(){const n=new F;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();O.prototype.distanceToTriangle=function(){const n=new F,t=new F,e=["a","b","c"],i=new k,s=new k;return function(r,l=null,c=null){const f=l||c?i:null;if(this.intersectsTriangle(r,f))return(l||c)&&(l&&f.getCenter(l),c&&f.getCenter(c)),0;let a=1/0;for(let u=0;u<3;u++){let p;const d=e[u],g=r[d];this.closestPointToPoint(g,n),p=g.distanceToSquared(n),p<a&&(a=p,l&&l.copy(n),c&&c.copy(g));const w=this[d];r.closestPointToPoint(w,n),p=w.distanceToSquared(n),p<a&&(a=p,l&&l.copy(w),c&&c.copy(n))}for(let u=0;u<3;u++){const p=e[u],d=e[(u+1)%3];i.set(this[p],this[d]);for(let g=0;g<3;g++){const w=e[g],A=e[(g+1)%3];s.set(r[w],r[A]),_t(i,s,n,t);const y=n.distanceToSquared(t);y<a&&(a=y,l&&l.copy(n),c&&c.copy(t))}}return Math.sqrt(a)}}();class q extends Y{constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new bt,this.invMatrix=new bt,this.points=new Array(8).fill().map(()=>new F),this.satAxes=new Array(3).fill().map(()=>new F),this.satBounds=new Array(3).fill().map(()=>new N),this.alignedSatBounds=new Array(3).fill().map(()=>new N),this.needsUpdate=!1}set(t,e,i){super.set(t,e),this.matrix=i,this.needsUpdate=!0}copy(t){super.copy(t),this.matrix.copy(t.matrix),this.needsUpdate=!0}}q.prototype.update=function(){return function(){const t=this.matrix,e=this.min,i=this.max,s=this.points;for(let f=0;f<=1;f++)for(let a=0;a<=1;a++)for(let u=0;u<=1;u++){const p=1*f|2*a|4*u,d=s[p];d.x=f?i.x:e.x,d.y=a?i.y:e.y,d.z=u?i.z:e.z,d.applyMatrix4(t)}const o=this.satBounds,r=this.satAxes,l=s[0];for(let f=0;f<3;f++){const a=r[f],u=o[f],p=1<<f,d=s[p];a.subVectors(l,d),u.setFromPoints(a,s)}const c=this.alignedSatBounds;c[0].setFromPointsField(s,"x"),c[1].setFromPointsField(s,"y"),c[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();q.prototype.intersectsBox=function(){const n=new N;return function(e){this.needsUpdate&&this.update();const i=e.min,s=e.max,o=this.satBounds,r=this.satAxes,l=this.alignedSatBounds;if(n.min=i.x,n.max=s.x,l[0].isSeparated(n)||(n.min=i.y,n.max=s.y,l[1].isSeparated(n))||(n.min=i.z,n.max=s.z,l[2].isSeparated(n)))return!1;for(let c=0;c<3;c++){const f=r[c],a=o[c];if(n.setFromBox(f,e),a.isSeparated(n))return!1}return!0}}();q.prototype.intersectsTriangle=function(){const n=new O,t=new Array(3),e=new N,i=new N,s=new F;return function(r){this.needsUpdate&&this.update(),r.isSeparatingAxisTriangle?r.needsUpdate&&r.update():(n.copy(r),n.update(),r=n);const l=this.satBounds,c=this.satAxes;t[0]=r.a,t[1]=r.b,t[2]=r.c;for(let p=0;p<3;p++){const d=l[p],g=c[p];if(e.setFromPoints(g,t),d.isSeparated(e))return!1}const f=r.satBounds,a=r.satAxes,u=this.points;for(let p=0;p<3;p++){const d=f[p],g=a[p];if(e.setFromPoints(g,u),d.isSeparated(e))return!1}for(let p=0;p<3;p++){const d=c[p];for(let g=0;g<4;g++){const w=a[g];if(s.crossVectors(d,w),e.setFromPoints(s,t),i.setFromPoints(s,u),e.isSeparated(i))return!1}}return!0}}();q.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();q.prototype.distanceToPoint=function(){const n=new F;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();q.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new k),e=new Array(12).fill().map(()=>new k),i=new F,s=new F;return function(r,l=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(c||f)&&(r.getCenter(s),this.closestPointToPoint(s,i),r.closestPointToPoint(i,s),c&&c.copy(i),f&&f.copy(s)),0;const a=l*l,u=r.min,p=r.max,d=this.points;let g=1/0;for(let A=0;A<8;A++){const y=d[A];s.copy(y).clamp(u,p);const m=y.distanceToSquared(s);if(m<g&&(g=m,c&&c.copy(y),f&&f.copy(s),m<a))return Math.sqrt(m)}let w=0;for(let A=0;A<3;A++)for(let y=0;y<=1;y++)for(let m=0;m<=1;m++){const h=(A+1)%3,x=(A+2)%3,b=y<<h|m<<x,T=1<<A|y<<h|m<<x,M=d[b],B=d[T];t[w].set(M,B);const S=n[A],I=n[h],v=n[x],z=e[w],U=z.start,E=z.end;U[S]=u[S],U[I]=y?u[I]:p[I],U[v]=m?u[v]:p[I],E[S]=p[S],E[I]=y?u[I]:p[I],E[v]=m?u[v]:p[I],w++}for(let A=0;A<=1;A++)for(let y=0;y<=1;y++)for(let m=0;m<=1;m++){s.x=A?p.x:u.x,s.y=y?p.y:u.y,s.z=m?p.z:u.z,this.closestPointToPoint(s,i);const h=s.distanceToSquared(i);if(h<g&&(g=h,c&&c.copy(i),f&&f.copy(s),h<a))return Math.sqrt(h)}for(let A=0;A<12;A++){const y=t[A];for(let m=0;m<12;m++){const h=e[m];_t(y,h,i,s);const x=i.distanceToSquared(s);if(x<g&&(g=x,c&&c.copy(i),f&&f.copy(s),x<a))return Math.sqrt(x)}}return Math.sqrt(g)}}();const ht=new F,yt=new F,mt=new F,$t=new at,Jt=new at,Kt=new at,Qt=new F;function Xe(n,t,e,i,s,o){let r;return o===Me?r=n.intersectTriangle(i,e,t,!0,s):r=n.intersectTriangle(t,e,i,o!==Se,s),r===null?null:{distance:n.origin.distanceTo(s),point:s.clone()}}function We(n,t,e,i,s,o,r){ht.fromBufferAttribute(t,i),yt.fromBufferAttribute(t,s),mt.fromBufferAttribute(t,o);const l=Xe(n,ht,yt,mt,Qt,r);if(l){e&&($t.fromBufferAttribute(e,i),Jt.fromBufferAttribute(e,s),Kt.fromBufferAttribute(e,o),l.uv=Et.getUV(Qt,ht,yt,mt,$t,Jt,Kt,new at));const c={a:i,b:s,c:o,normal:new F,materialIndex:0};Et.getNormal(ht,yt,mt,c.normal),l.face=c,l.faceIndex=i}return l}function ue(n,t,e,i,s){const o=i*3,r=n.index.getX(o),l=n.index.getX(o+1),c=n.index.getX(o+2),f=We(e,n.attributes.position,n.attributes.uv,r,l,c,t);return f?(f.faceIndex=i,s&&s.push(f),f):null}function Ye(n,t,e,i,s,o){for(let r=i,l=i+s;r<l;r++)ue(n,t,e,r,o)}function Ze(n,t,e,i,s){let o=1/0,r=null;for(let l=i,c=i+s;l<c;l++){const f=ue(n,t,e,l);f&&f.distance<o&&(r=f,o=f.distance)}return r}function pe(n,t,e){return n===null||(n.point.applyMatrix4(t.matrixWorld),n.distance=n.point.distanceTo(e.ray.origin),n.object=t,n.distance<e.near||n.distance>e.far)?null:n}function D(n,t,e,i){const s=n.a,o=n.b,r=n.c;let l=t,c=t+1,f=t+2;e&&(l=e.getX(t),c=e.getX(t+1),f=e.getX(t+2)),s.x=i.getX(l),s.y=i.getY(l),s.z=i.getZ(l),o.x=i.getX(c),o.y=i.getY(c),o.z=i.getZ(c),r.x=i.getX(f),r.y=i.getY(f),r.z=i.getZ(f)}function te(n,t,e,i,s,o,r){const l=e.index,c=e.attributes.position;for(let f=n,a=t+n;f<a;f++)if(D(r,f*3,l,c),r.needsUpdate=!0,i(r,f,s,o))return!0;return!1}class de{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function j(n,t){return t[n+15]===65535}function Q(n,t){return t[n+6]}function ot(n,t){return t[n+14]}function rt(n){return n+8}function ct(n,t){return t[n+6]}function $e(n,t){return t[n+7]}const K=new Y,Pt=new F,Je=["x","y","z"];function Ut(n,t,e,i,s){let o=n*2,r=tt,l=X,c=W;if(j(o,l)){const a=Q(n,c),u=ot(o,l);Ye(t,e,i,a,u,s)}else{const a=rt(n);Bt(a,r,i,Pt)&&Ut(a,t,e,i,s);const u=ct(n,c);Bt(u,r,i,Pt)&&Ut(u,t,e,i,s)}}function Vt(n,t,e,i){let s=n*2,o=tt,r=X,l=W;if(j(s,r)){const f=Q(n,l),a=ot(s,r);return Ze(t,e,i,f,a)}else{const f=$e(n,l),a=Je[f],p=i.direction[a]>=0;let d,g;p?(d=rt(n),g=ct(n,l)):(d=ct(n,l),g=rt(n));const A=Bt(d,o,i,Pt)?Vt(d,t,e,i):null;if(A){const h=A.point[a];if(p?h<=o[g+f]:h>=o[g+f+3])return A}const m=Bt(g,o,i,Pt)?Vt(g,t,e,i):null;return A&&m?A.distance<=m.distance?A:m:A||m||null}}const Ke=function(){let n,t;const e=[],i=new de(()=>new Y);return function(...r){n=i.getPrimitive(),t=i.getPrimitive(),e.push(n,t);const l=s(...r);i.releasePrimitive(n),i.releasePrimitive(t),e.pop(),e.pop();const c=e.length;return c>0&&(t=e[c-1],n=e[c-2]),l};function s(o,r,l,c,f=null,a=0,u=0){function p(h){let x=h*2,b=X,T=W;for(;!j(x,b);)h=rt(h),x=h*2;return Q(h,T)}function d(h){let x=h*2,b=X,T=W;for(;!j(x,b);)h=ct(h,T),x=h*2;return Q(h,T)+ot(x,b)}let g=o*2,w=tt,A=X,y=W;if(j(g,A)){const h=Q(o,y),x=ot(g,A);return _(o,w,n),c(h,x,!1,u,a+o,n)}else{const h=rt(o),x=ct(o,y);let b=h,T=x,M,B,P,S;if(f&&(P=n,S=t,_(b,w,P),_(T,w,S),M=f(P),B=f(S),B<M)){b=x,T=h;const R=M;M=B,B=R,P=S}P||(P=n,_(b,w,P));const I=j(b*2,A),v=l(P,I,M,u+1,a+b);let z;if(v===jt){const R=p(b),$=d(b)-R;z=c(R,$,!0,u+1,a+b,P)}else z=v&&s(b,r,l,c,f,a,u+1);if(z)return!0;S=t,_(T,w,S);const U=j(T*2,A),E=l(S,U,B,u+1,a+T);let V;if(E===jt){const R=p(T),$=d(T)-R;V=c(R,$,!0,u+1,a+T,S)}else V=E&&s(T,r,l,c,f,a,u+1);return!!V}}}(),Qe=function(){const n=new O,t=new O,e=new bt,i=new q,s=new q;return function o(r,l,c,f,a=null){let u=r*2,p=tt,d=X,g=W;if(a===null&&(c.boundingBox||c.computeBoundingBox(),i.set(c.boundingBox.min,c.boundingBox.max,f),a=i),j(u,d)){const A=l,y=A.index,m=A.attributes.position,h=c.index,x=c.attributes.position,b=Q(r,g),T=ot(u,d);if(e.copy(f).invert(),c.boundsTree)return _(r,p,s),s.matrix.copy(e),s.needsUpdate=!0,c.boundsTree.shapecast({intersectsBounds:B=>s.intersectsBox(B),intersectsTriangle:B=>{B.a.applyMatrix4(f),B.b.applyMatrix4(f),B.c.applyMatrix4(f),B.needsUpdate=!0;for(let P=b*3,S=(T+b)*3;P<S;P+=3)if(D(t,P,y,m),t.needsUpdate=!0,B.intersectsTriangle(t))return!0;return!1}});for(let M=b*3,B=T+b*3;M<B;M+=3){D(n,M,y,m),n.a.applyMatrix4(e),n.b.applyMatrix4(e),n.c.applyMatrix4(e),n.needsUpdate=!0;for(let P=0,S=h.count;P<S;P+=3)if(D(t,P,h,x),t.needsUpdate=!0,n.intersectsTriangle(t))return!0}}else{const A=r+8,y=g[r+6];return _(A,p,K),!!(a.intersectsBox(K)&&o(A,l,c,f,a)||(_(y,p,K),a.intersectsBox(K)&&o(y,l,c,f,a)))}}}();function Bt(n,t,e,i){return _(n,t,K),e.intersectBox(K,i)}const Rt=[];let gt,tt,X,W;function it(n){gt&&Rt.push(gt),gt=n,tt=new Float32Array(n),X=new Uint16Array(n),W=new Uint32Array(n)}function xt(){gt=null,tt=null,X=null,W=null,Rt.length&&it(Rt.pop())}const vt=Symbol("skip tree generation"),Ft=new Y,zt=new Y,J=new bt,Z=new q,nt=new q,st=new F,wt=new F,tn=new F,en=new F,nn=new F,ee=new Y,L=new de(()=>new O);class C{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),C.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});e=ft({cloneBuffers:!0},e);const i=t.geometry,s=t._roots,o=i.getIndex();let r;return e.cloneBuffers?r={roots:s.map(l=>l.slice()),index:o.array.slice()}:r={roots:s,index:o.array},r}static deserialize(t,e,i={}){if(typeof i=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),C.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});i=ft({setIndex:!0},i);const{index:s,roots:o}=t,r=new C(e,Ot(ft({},i),{[vt]:!0}));if(r._roots=o,i.setIndex){const l=e.getIndex();if(l===null){const c=new Tt(t.index,1,!1);e.setIndex(c)}else l.array!==s&&(l.array.set(s),l.needsUpdate=!0)}return r}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:fe,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[vt]:!1},e),e.useSharedArrayBuffer&&typeof SharedArrayBuffer=="undefined")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[vt]||(this._roots=Oe(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Y))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,i=e.index.array,s=e.attributes.position,o=s.array,r=s.offset||0;let l=3;s.isInterleavedBufferAttribute&&(l=s.data.stride);let c,f,a,u,p=0;const d=this._roots;for(let w=0,A=d.length;w<A;w++)c=d[w],f=new Uint32Array(c),a=new Uint16Array(c),u=new Float32Array(c),g(0,p),p+=c.byteLength;function g(w,A,y=!1){const m=w*2;if(a[m+15]===Ct){const x=f[w+6],b=a[m+14];let T=1/0,M=1/0,B=1/0,P=-1/0,S=-1/0,I=-1/0;for(let v=3*x,z=3*(x+b);v<z;v++){const U=i[v]*l+r,E=o[U+0],V=o[U+1],R=o[U+2];E<T&&(T=E),E>P&&(P=E),V<M&&(M=V),V>S&&(S=V),R<B&&(B=R),R>I&&(I=R)}return u[w+0]!==T||u[w+1]!==M||u[w+2]!==B||u[w+3]!==P||u[w+4]!==S||u[w+5]!==I?(u[w+0]=T,u[w+1]=M,u[w+2]=B,u[w+3]=P,u[w+4]=S,u[w+5]=I,!0):!1}else{const x=w+8,b=f[w+6],T=x+A,M=b+A;let B=y,P=!1,S=!1;t?B||(P=t.has(T),S=t.has(M),B=!P&&!S):(P=!0,S=!0);const I=B||P,v=B||S;let z=!1;I&&(z=g(x,A,B));let U=!1;v&&(U=g(b,A,B));const E=z||U;if(E)for(let V=0;V<3;V++){const R=x+V,lt=b+V,$=u[R],Dt=u[R+3],Nt=u[lt],qt=u[lt+3];u[w+V]=$<Nt?$:Nt,u[w+V+3]=Dt>qt?Dt:qt}return E}}}traverse(t,e=0){const i=this._roots[e],s=new Uint32Array(i),o=new Uint16Array(i);r(0);function r(l,c=0){const f=l*2,a=o[f+15]===Ct;if(a){const u=s[l+6],p=o[f+14];t(c,a,new Float32Array(i,l*4,6),u,p)}else{const u=l+At/4,p=s[l+6],d=s[l+7];t(c,a,new Float32Array(i,l*4,6),d)||(r(u,c+1),r(p,c+1))}}}raycast(t,e=Gt){const i=this._roots,s=this.geometry,o=[],r=e.isMaterial,l=Array.isArray(e),c=s.groups,f=r?e.side:e;for(let a=0,u=i.length;a<u;a++){const p=l?e[c[a].materialIndex].side:f,d=o.length;if(it(i[a]),Ut(0,s,p,t,o),xt(),l){const g=c[a].materialIndex;for(let w=d,A=o.length;w<A;w++)o[w].face.materialIndex=g}}return o}raycastFirst(t,e=Gt){const i=this._roots,s=this.geometry,o=e.isMaterial,r=Array.isArray(e);let l=null;const c=s.groups,f=o?e.side:e;for(let a=0,u=i.length;a<u;a++){const p=r?e[c[a].materialIndex].side:f;it(i[a]);const d=Vt(0,s,p,t);xt(),d!=null&&(l==null||d.distance<l.distance)&&(l=d,r&&(d.face.materialIndex=c[a].materialIndex))}return l}intersectsGeometry(t,e){const i=this.geometry;let s=!1;for(const o of this._roots)if(it(o),s=Qe(0,i,t,e),xt(),s)break;return s}shapecast(t,e,i){const s=this.geometry;if(t instanceof Function){if(e){const p=e;e=(d,g,w,A)=>{const y=g*3;return p(d,y,y+1,y+2,w,A)}}t={boundsTraverseOrder:i,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const o=L.getPrimitive();let{boundsTraverseOrder:r,intersectsBounds:l,intersectsRange:c,intersectsTriangle:f}=t;if(c&&f){const p=c;c=(d,g,w,A,y)=>p(d,g,w,A,y)?!0:te(d,g,s,f,w,A,o)}else c||(f?c=(p,d,g,w)=>te(p,d,s,f,g,w,o):c=(p,d,g)=>g);let a=!1,u=0;for(const p of this._roots){if(it(p),a=Ke(0,s,l,c,r,u),xt(),a)break;u+=p.byteLength}return L.releasePrimitive(o),a}bvhcast(t,e,i){let{intersectsRanges:s,intersectsTriangles:o}=i;const r=this.geometry.index,l=this.geometry.attributes.position,c=t.geometry.index,f=t.geometry.attributes.position;J.copy(e).invert();const a=L.getPrimitive(),u=L.getPrimitive();if(o){let d=function(g,w,A,y,m,h,x,b){for(let T=A,M=A+y;T<M;T++){D(u,T*3,c,f),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let B=g,P=g+w;B<P;B++)if(D(a,B*3,r,l),a.needsUpdate=!0,o(a,u,B,T,m,h,x,b))return!0}return!1};if(s){const g=s;s=function(w,A,y,m,h,x,b,T){return g(w,A,y,m,h,x,b,T)?!0:d(w,A,y,m,h,x,b,T)}}else s=d}this.getBoundingBox(zt),zt.applyMatrix4(e);const p=this.shapecast({intersectsBounds:d=>zt.intersectsBox(d),intersectsRange:(d,g,w,A,y,m)=>(Ft.copy(m),Ft.applyMatrix4(J),t.shapecast({intersectsBounds:h=>Ft.intersectsBox(h),intersectsRange:(h,x,b,T,M)=>s(d,g,h,x,A,y,T,M)}))});return L.releasePrimitive(a),L.releasePrimitive(u),p}intersectsBox(t,e){return Z.set(t.min,t.max,e),Z.needsUpdate=!0,this.shapecast({intersectsBounds:i=>Z.intersectsBox(i),intersectsTriangle:i=>Z.intersectsTriangle(i)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,i={},s={},o=0,r=1/0){t.boundingBox||t.computeBoundingBox(),Z.set(t.boundingBox.min,t.boundingBox.max,e),Z.needsUpdate=!0;const l=this.geometry,c=l.attributes.position,f=l.index,a=t.attributes.position,u=t.index,p=L.getPrimitive(),d=L.getPrimitive();let g=wt,w=tn,A=null,y=null;s&&(A=en,y=nn);let m=1/0,h=null,x=null;return J.copy(e).invert(),nt.matrix.copy(J),this.shapecast({boundsTraverseOrder:b=>Z.distanceToBox(b,Math.min(m,r)),intersectsBounds:(b,T,M)=>M<m&&M<r?(T&&(nt.min.copy(b.min),nt.max.copy(b.max),nt.needsUpdate=!0),!0):!1,intersectsRange:(b,T)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:M=>nt.distanceToBox(M,Math.min(m,r)),intersectsBounds:(M,B,P)=>P<m&&P<r,intersectsRange:(M,B)=>{for(let P=M*3,S=(M+B)*3;P<S;P+=3){D(d,P,u,a),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let I=b*3,v=(b+T)*3;I<v;I+=3){D(p,I,f,c),p.needsUpdate=!0;const z=p.distanceToTriangle(d,g,A);if(z<m&&(w.copy(g),y&&y.copy(A),m=z,h=I/3,x=P/3),z<o)return!0}}}});{const M=u?u.count:a.count;for(let B=0,P=M;B<P;B+=3){D(d,B,u,a),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let S=b*3,I=(b+T)*3;S<I;S+=3){D(p,S,f,c),p.needsUpdate=!0;const v=p.distanceToTriangle(d,g,A);if(v<m&&(w.copy(g),y&&y.copy(A),m=v,h=S/3,x=B/3),v<o)return!0}}}}}),L.releasePrimitive(p),L.releasePrimitive(d),m===1/0?null:(i.point?i.point.copy(w):i.point=w.clone(),i.distance=m,i.faceIndex=h,s&&(s.point?s.point.copy(y):s.point=y.clone(),s.point.applyMatrix4(J),w.applyMatrix4(J),s.distance=w.sub(s.point).length(),s.faceIndex=x),i)}closestPointToPoint(t,e={},i=0,s=1/0){const o=i*i,r=s*s;let l=1/0,c=null;if(this.shapecast({boundsTraverseOrder:a=>(st.copy(t).clamp(a.min,a.max),st.distanceToSquared(t)),intersectsBounds:(a,u,p)=>p<l&&p<r,intersectsTriangle:(a,u)=>{a.closestPointToPoint(t,st);const p=t.distanceToSquared(st);return p<l&&(wt.copy(st),l=p,c=u),p<o}}),l===1/0)return null;const f=Math.sqrt(l);return e.point?e.point.copy(wt):e.point=wt.clone(),e.distance=f,e.faceIndex=c,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(i=>{_(0,new Float32Array(i),ee),t.union(ee)}),t}}const ne=C.prototype.raycast;C.prototype.raycast=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');const[t,e,i,s]=n;return ne.call(this,i,t.material).forEach(r=>{r=pe(r,t,e),r&&s.push(r)}),s}else return ne.apply(this,n)};const se=C.prototype.raycastFirst;C.prototype.raycastFirst=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');const[t,e,i]=n;return pe(se.call(this,i,t.material),t,e)}else return se.apply(this,n)};const ie=C.prototype.closestPointToPoint;C.prototype.closestPointToPoint=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),n.unshift();const t=n[1],e={};return n[1]=e,ie.apply(this,n),t&&t.copy(e.point),e.distance}else return ie.apply(this,n)};const oe=C.prototype.closestPointToGeometry;C.prototype.closestPointToGeometry=function(...n){const t=n[2],e=n[3];if(t&&t.isVector3||e&&e.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');const i={},s={},o=n[1];return n[2]=i,n[3]=s,oe.apply(this,n),t&&t.copy(i.point),e&&e.copy(s.point).applyMatrix4(o),i.distance}else return oe.apply(this,n)};const re=C.prototype.refit;C.prototype.refit=function(...n){const t=n[0],e=n[1];if(e&&(e instanceof Set||Array.isArray(e))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');const i=new Set;e.forEach(s=>i.add(s)),t&&t.forEach(s=>i.add(s)),re.call(this,i)}else re.apply(this,n)};["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach(n=>{const t=C.prototype[n];C.prototype[n]=function(...e){return(e[0]===null||e[0].isMesh)&&(e.shift(),console.warn(`MeshBVH: The function signature for "${n}" has changed and no longer takes Mesh. See docs for new signature.`)),t.apply(this,e)}});const ce=new Y;class sn extends ge{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,i=10,s=0){super(),this.material=e,this.geometry=new be,this.name="MeshBVHRootVisualizer",this.depth=i,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=s}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,i=this._group;if(t.dispose(),this.visible=!1,e){const s=this.depth-1,o=this.displayParents;let r=0;e.traverse((p,d)=>{if(p===s||d)return r++,!0;o&&r++},i);let l=0;const c=new Float32Array(8*3*r);e.traverse((p,d,g)=>{const w=p===s||d;if(w||o){_(0,g,ce);const{min:A,max:y}=ce;for(let m=-1;m<=1;m+=2){const h=m<0?A.x:y.x;for(let x=-1;x<=1;x+=2){const b=x<0?A.y:y.y;for(let T=-1;T<=1;T+=2){const M=T<0?A.z:y.z;c[l+0]=h,c[l+1]=b,c[l+2]=M,l+=3}}}return w}},i);let f,a;this.displayEdges?a=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):a=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),c.length>65535?f=new Uint32Array(a.length*r):f=new Uint16Array(a.length*r);const u=a.length;for(let p=0;p<r;p++){const d=p*8,g=p*u;for(let w=0;w<u;w++)f[g+w]=d+a[w]}t.setIndex(new Tt(f,1,!1)),t.setAttribute("position",new Tt(c,3,!1)),this.visible=!0}}}class Lt extends Te{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const i=new Pe({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),s=new Be({color:65416,transparent:!0,opacity:.3,depthWrite:!1});s.color=i.color,this.edgeMaterial=i,this.meshMaterial=s,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;)this._roots.pop();for(let i=0;i<e;i++){if(i>=this._roots.length){const o=new sn(this.mesh,this.edgeMaterial,this.depth,i);this.add(o),this._roots.push(o)}const s=this._roots[i];s.depth=this.depth,s.mesh=this.mesh,s.displayParents=this.displayParents,s.displayEdges=this.displayEdges,s.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,s.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new Lt(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,i=t.length;e<i;e++)t[e].geometry.dispose()}}le.prototype.raycast;const on=new WeakMap;async function Bn(n,t){if(n.done)return;Mt.attach(this.outerObject3d);const e=[];this.outerObject3d.updateMatrixWorld(!0),this.outerObject3d.traverse(s=>{if(!s.geometry||s===this.object3d&&!(this instanceof Ie))return;const o=s.geometry.clone();o.applyMatrix4(s.matrixWorld),e.push(o),o.dispose()});const i=[];for(const s of e){const o=s.boundsTree=new C(s);i.push(o),on.set(o,this)}for(const s of i)Fe(s);if(n.then(()=>{for(const s of i)ze(s)}),t)for(const s of e){const o=new Lt(new le(s,ve),20);Mt.add(o),n.then(()=>Mt.remove(o))}}export{on as bvhManagerMap,Bn as default};
